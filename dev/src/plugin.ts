import type { Plugin } from 'vite';
import { Project, Node, FunctionDeclaration, ArrowFunction } from 'ts-morph';
import path from 'path';
import fs from 'node:fs';
import fsAsync from 'node:fs/promises';
import fg from 'fast-glob'; // For globbing files

const RPC_FILES_GLOB = 'src/**/*.telephone.ts';

// Parameter information for server-side validation
interface ParamInfo {
  name: string;
  type: string | object;
  optional: boolean;
}

// Information about an exported function, including for client stub generation
// and server-side validation.
interface ExportedFunctionInfo {
  name: string;
  // For client stub generation (e.g., "p0, p1")
  clientParameterStr: string;
  clientArgumentStr: string;
  // For server-side validation
  params: ParamInfo[];
}

interface FileInfo {
  relativePath: string;
}

export interface Config {
  debug: boolean
}

const PLUGIN_NAME = 'vite-sveltekit-telephone';

export default function plugin(config: Config = {debug: false}): Plugin {
  const debug = config?.debug ?? false
  const project = new Project();
  let resolvedRpcFiles: string[] = []; // Store absolute paths of RPC files
  let resolvedRelativeRpcFiles: string[] = []; // Store relative paths of RPC files
  let rpcFileMap: Record<string, FileInfo> = {};
  // let viteConfig: ResolvedConfig;
  let generateDirPath: string;

  async function generateFiles() {
    if (!generateDirPath) return;

    let count = 0
    let output= `
// DO NOT MODIFY
// Auto Generated by ${PLUGIN_NAME}

// Type definition for parameter info
export interface ParamInfo {
  name: string;
  type: string|object;
  optional: boolean;
}

// Type definition for the structure stored in functionMap
export interface FunctionDetail {
  fn: (...args: any[]) => any;
  params: ParamInfo[];
}

export const functionMap: Record<string, Record<string, FunctionDetail>> = {};
`;

    for (const filePath of resolvedRelativeRpcFiles) {
      const moduleAlias = `m${count}`;
      const fileImportPath = filePath.replace(/^src\/lib/, "$lib").replace(/^src\//, "../../../").replace(/\.ts$/, "");
      output += `
import * as ${moduleAlias} from "${fileImportPath}";`;

      // Get exported function details for this file
      // Note: Using absolute path for getExportedFunctionDetails
      const absoluteFilePath = resolvedRpcFiles.find(absPath => absPath.endsWith(filePath.replace(/\//g, path.sep)));
      if (!absoluteFilePath) {
        console.warn(`[${PLUGIN_NAME}] Could not find absolute path for ${filePath}. Skipping for functionMap generation.`);
        continue;
      }
      const functionDetails = getExportedFunctionDetails(absoluteFilePath);

      output += `
functionMap["${filePath}"] = {`;
      for (const funcDetail of functionDetails) {
        output += `
  "${funcDetail.name}": { fn: ${moduleAlias}.${funcDetail.name}, params: ${JSON.stringify(funcDetail.params)} },`;
      }
      output += `
};
`;
      count++;
    }

    const outputDir = path.join(generateDirPath);
    await fsAsync.mkdir(outputDir, { recursive: true });

    const indexPath = path.join(outputDir, 'index.ts');
    await fsAsync.writeFile(indexPath, output);
    log("Generated", indexPath)


    // If your generated .ts files are simple enough, TS might infer types.
    // But explicitly generating .d.ts can be more robust or necessary for complex types.
    // Often, you might generate .ts and rely on the user's TS compilation.
    // If you generate pure .d.ts files, then the 'load' hook might be needed for JS output.
    // For this example, let's assume we generate .ts files that TS will pick up.
    // We could also generate a top-level .d.ts that re-exports types.
  }

  function log(...args: any[]) {
    if (debug) {
      console.log(PLUGIN_NAME, ...args)
    }
  }

  return {
    name: PLUGIN_NAME,

    configResolved(config) {
      log("Config resolved", config.root)
      // viteConfig = config;
      const globPattern = path.join(config.root, RPC_FILES_GLOB).replace(/\\/g, '/');
      resolvedRpcFiles = fg.sync(globPattern, { absolute: true });
      const relativeGlobPattern = RPC_FILES_GLOB.replace(/\\/g, '/');
      resolvedRelativeRpcFiles = fg.sync(relativeGlobPattern, { absolute: false});
      rpcFileMap = {}
      for (const f of resolvedRpcFiles) {
        const relativePath = path.relative(config.root, f);
        rpcFileMap[f] = {relativePath};
      }


      log('Found RPC files:', resolvedRpcFiles.map(p => path.relative(config.root, p)));
      // generatedDirPath = path.resolve(config.root, '.svelte-kit', 'generated', PLUGIN_NAME);
      generateDirPath = path.resolve(config.root, 'src', 'lib', 'client', '_'+PLUGIN_NAME);
    },

    async buildStart() {
      await generateFiles();
    },

    transform(code, id, options) {
      const normalizedId = path.normalize(id);
      // Check if we are transforming the target server functions file
      // AND if this transformation is for the client bundle (not SSR)
      if (resolvedRpcFiles.includes(normalizedId) && !options?.ssr) {
        // if (id.endsWith(SERVER_FUNCTIONS_VITE_ID_SUFFIX) && !options?.ssr) {
        log(`Transforming ${id} for client`);
        const fileInfo = rpcFileMap[id]
        if (fileInfo) {
          let clientStubs = makeClientStub(debug, fileInfo.relativePath);
          // getExportedFunctionDetails is the new function that returns more info,
          // but for client stubs, we only need the name and dummy param strings.
          const exportedFunctionInfos: ExportedFunctionInfo[] = getExportedFunctionDetails(id);

          for (const efInfo of exportedFunctionInfos) {
            log("exporting function for client stub:", efInfo.name)
            clientStubs += `
export async function ${efInfo.name}(${efInfo.clientParameterStr}) {
  return makeSpecificRpcCall('${efInfo.name}', [${efInfo.clientArgumentStr}]);
}
`;
          }

          return {
            code: clientStubs,
            map: null, // TODO: generate source maps
          };
        } else {
          console.error("Couldn't find file in map", id)
        }
      }

      // For SSR builds or any other files, return null to not transform
      return null;
    },
  };

  // Renamed from getExportedFunctions to getExportedFunctionDetails and updated return type
  function getExportedFunctionDetails(filePath: string): ExportedFunctionInfo[] {
    // Add the server functions file as a dependency for HMR
    // `this.addWatchFile` is available in `load` and `resolveId`
    // For `transform`, Vite automatically re-runs it if the file changes.
    // However, if you need to trigger a full reload for other reasons related to this file,
    // you might need more complex HMR handling or ensure `this.addWatchFile`
    // is called elsewhere (e.g. in a `configResolved` hook if needed).
    // For simple content transform, Vite's default behavior is often sufficient.


    // Parse the original file to get signatures
    // It's better to read the fresh file content rather than relying on the `code`
    // argument if other plugins might have already transformed it in a way
    // that breaks ts-morph parsing. However, for this specific case, `code` is usually fine.
    // For robustness with ts-morph, let's re-read:
    // const fileContent = fs.readFileSync(filePath, 'utf-8');
    // const sourceFile = project.createSourceFile(filePath + ".temp.ts", fileContent, { overwrite: true });
    const sourceFile = project.addSourceFileAtPathIfExists(filePath) || project.createSourceFile(filePath + ".temp.ts", fs.readFileSync(filePath, 'utf-8'));
    if (!sourceFile) {
      log(`Could not create source file for ${filePath}`);
      return [];
    }
    sourceFile.refreshFromFileSystemSync();


    const exportedDeclarations = sourceFile.getExportedDeclarations();
    const exportedFunctionInfos: ExportedFunctionInfo[] = [];

    for (const [name, declarations] of exportedDeclarations) {
      const decl = declarations[0];
      let funcNode: FunctionDeclaration | ArrowFunction | undefined;

      if (Node.isFunctionDeclaration(decl) || Node.isArrowFunction(decl)) {
        funcNode = decl;
      } else if (Node.isVariableDeclaration(decl) && decl.getInitializer() &&
        (Node.isArrowFunction(decl.getInitializerOrThrow()) || Node.isFunctionExpression(decl.getInitializerOrThrow()))) {
        funcNode = decl.getInitializerOrThrow() as ArrowFunction;
      }

      if (funcNode) {
        const params: ParamInfo[] = funcNode.getParameters().map(p => {
          const paramType = p.getTypeNode()?.getText();
          const type = paramType ? transformTypeToJson(paramType) : "any";
          return {
            name: p.getName(),
            type,
            optional: p.hasQuestionToken() || p.isOptional() || p.isRestParameter() || !!p.getInitializer(),
          };
        });

        const numParams = funcNode.getParameters().length; // Used for client stub generation
        const clientDummyParams = new Array(numParams).fill(0);

        exportedFunctionInfos.push({
          name,
          clientParameterStr: clientDummyParams.map((_, i) => `p${i}`).join(", "),
          clientArgumentStr: clientDummyParams.map((_, i) => `p${i}`).join(', '),
          params, // Detailed parameter info for server-side
        });
      }
    }

    // If we created a temporary source file, remove it.
    // If addSourceFileAtPathIfExists found it, it's managed by the project.
    if (sourceFile.getFilePath().endsWith(".temp.ts")) {
        project.removeSourceFile(sourceFile);
    }

    return exportedFunctionInfos;
  }
}

function makeClientStub(debug: boolean, filePath: string) {
  return `
// Generated by vite-plugin-sveltekit-telephone-dev
${debug ? "// Based on file: ${filePath}" : ""}
import { makeRpcCall } from 'vite-plugin-sveltekit-telephone-prod/client';

const filePath = ${JSON.stringify(filePath)}

async function makeSpecificRpcCall(functionName, args) {
    return await makeRpcCall(filePath, functionName, args)
}
`;
}

export function transformTypeToJson(typeStr: string): string | object {
  const trimmed = typeStr.trim();
  
  // Handle basic types directly
  if (!trimmed.includes('{') && !trimmed.includes('<')) {
    return trimmed;
  }

  // Handle object types
  if (trimmed.startsWith('{') && trimmed.endsWith('}')) {
    const inner = trimmed.slice(1, -1);
    const returnObject: Record<string, any> = {};
    
    let depth = 0;
    let currentPair = '';
    
    // Parse with nested structure awareness
    for (let i = 0; i < inner.length; i++) {
      const char = inner[i];
      if (char === '{') depth++;
      if (char === '}') depth--;
      
      if ((char === ',' || char === ';') && depth === 0) {
        processPair(currentPair, returnObject);
        currentPair = '';
      } else {
        currentPair += char;
      }
    }
    if (currentPair) {
      processPair(currentPair, returnObject);
    }
    
    return returnObject;
  }

  return typeStr;
}

function processPair(pair: string, obj: Record<string, any>) {
  const colonIndex = pair.indexOf(':');
  const key = pair.slice(0, colonIndex).trim();
  const value = pair.slice(colonIndex + 1).trim();
  if (key && value) {
    obj[key] = transformTypeToJson(value);
  }
}