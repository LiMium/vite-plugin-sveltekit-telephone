import type { Plugin } from 'vite';
import { Project, Node, FunctionDeclaration, ArrowFunction } from 'ts-morph';
import path from 'path';
import fs from 'node:fs/promises';
import fg from 'fast-glob'; // For globbing files

const RPC_FILES_GLOB = 'src/**/*.telephone.ts';

interface ExportedFunction {
  name: string,
  parameterStr: string,
  argumentStr: string
};

interface FileInfo {
  relativePath: string,
}

export interface Config {
  debug: boolean
}

const PLUGIN_NAME = 'vite-sveltekit-telephone';

export default function plugin(config: Config = {debug: false}): Plugin {
  const debug = config?.debug ?? false
  const project = new Project();
  let resolvedRpcFiles: string[] = []; // Store absolute paths of RPC files
  let resolvedRelativeRpcFiles: string[] = []; // Store relative paths of RPC files
  let rpcFileMap: Record<string, FileInfo> = {};
  // let viteConfig: ResolvedConfig;
  let generateDirPath: string;

  async function generateFiles() {
    if (!generateDirPath) return;

    let count = 0
    let output= `
// DO NOT MODIFY
// Auto Generated by ${PLUGIN_NAME}
export const functionMap: Record<string, any> = {}
`;

    for (const filePath of resolvedRelativeRpcFiles) {
      const file = filePath.replace(/^src\/lib/, "$lib").replace(/^src\//, "../../../").replace(/\.ts$/, "");
      output += `
import * as ${"f"+count} from "${file}";
functionMap["${filePath}"] = ${"f"+count};
`
      count++;
    }


    const outputDir = path.join(generateDirPath);
    await fs.mkdir(outputDir, { recursive: true });

    const indexPath = path.join(outputDir, 'index.ts');
    await fs.writeFile(indexPath, output);
    log("Generated", indexPath)


    // If your generated .ts files are simple enough, TS might infer types.
    // But explicitly generating .d.ts can be more robust or necessary for complex types.
    // Often, you might generate .ts and rely on the user's TS compilation.
    // If you generate pure .d.ts files, then the 'load' hook might be needed for JS output.
    // For this example, let's assume we generate .ts files that TS will pick up.
    // We could also generate a top-level .d.ts that re-exports types.
  }

  function log(...args: any[]) {
    if (debug) {
      console.log(PLUGIN_NAME, ...args)
    }
  }

  return {
    name: PLUGIN_NAME,

    configResolved(config) {
      log("Config resolved", config.root)
      // viteConfig = config;
      const globPattern = path.join(config.root, RPC_FILES_GLOB).replace(/\\/g, '/');
      resolvedRpcFiles = fg.sync(globPattern, { absolute: true });
      const relativeGlobPattern = RPC_FILES_GLOB.replace(/\\/g, '/');
      resolvedRelativeRpcFiles = fg.sync(relativeGlobPattern, { absolute: false});
      rpcFileMap = {}
      for (const f of resolvedRpcFiles) {
        const relativePath = path.relative(config.root, f);
        rpcFileMap[f] = {relativePath};
      }


      log('Found RPC files:', resolvedRpcFiles.map(p => path.relative(config.root, p)));
      // generatedDirPath = path.resolve(config.root, '.svelte-kit', 'generated', PLUGIN_NAME);
      generateDirPath = path.resolve(config.root, 'src', 'lib', 'client', '_'+PLUGIN_NAME);
    },

    async buildStart() {
      await generateFiles();
    },

    transform(code, id, options) {
      const normalizedId = path.normalize(id);
      // Check if we are transforming the target server functions file
      // AND if this transformation is for the client bundle (not SSR)
      if (resolvedRpcFiles.includes(normalizedId) && !options?.ssr) {
        // if (id.endsWith(SERVER_FUNCTIONS_VITE_ID_SUFFIX) && !options?.ssr) {
        log(`Transforming ${id} for client`);
        const fileInfo = rpcFileMap[id]
        if (fileInfo) {
          let clientStubs = makeClientStub(debug, fileInfo.relativePath);
          const exportedFunctions: ExportedFunction[] = getExportedFunctions(id);

          for (const ef of exportedFunctions) {
            log("exporting function:", ef)
            clientStubs += `
export async function ${ef.name}(${ef.parameterStr}) {
  return makeSpecificRpcCall('${ef.name}', [${ef.argumentStr}]);
}
`;
          }

          return {
            code: clientStubs,
            map: null, // TODO: generate source maps
          };
        } else {
          console.error("Couldn't find file in map", id)
        }
      }

      // For SSR builds or any other files, return null to not transform
      return null;
    },
  };

  function getExportedFunctions(path: string): ExportedFunction[] {
    // Add the server functions file as a dependency for HMR
    // `this.addWatchFile` is available in `load` and `resolveId`
    // For `transform`, Vite automatically re-runs it if the file changes.
    // However, if you need to trigger a full reload for other reasons related to this file,
    // you might need more complex HMR handling or ensure `this.addWatchFile`
    // is called elsewhere (e.g. in a `configResolved` hook if needed).
    // For simple content transform, Vite's default behavior is often sufficient.


    // Parse the original file to get signatures
    // It's better to read the fresh file content rather than relying on the `code`
    // argument if other plugins might have already transformed it in a way
    // that breaks ts-morph parsing. However, for this specific case, `code` is usually fine.
    // For robustness with ts-morph, let's re-read:
    // const fileContent = fs.readFileSync(id, 'utf-8');
    // const sourceFile = project.createSourceFile(id + ".temp.ts", fileContent, { overwrite: true });
    // const sourceFile = project.createSourceFile(id + ".temp.js", fileContent, { overwrite: true });
    const sourceFile = project.addSourceFileAtPath(path);
    sourceFile.refreshFromFileSystemSync(); // if using addSourceFileAtPath

    const exportedDeclarations = sourceFile.getExportedDeclarations();

    let exportedFunctions = [];

    for (const [name, declarations] of exportedDeclarations) {
      const decl = declarations[0];
      let funcNode: FunctionDeclaration | ArrowFunction | undefined;

      if (Node.isFunctionDeclaration(decl) || Node.isArrowFunction(decl)) {
        funcNode = decl;
      } else if (Node.isVariableDeclaration(decl) && decl.getInitializer() &&
        (Node.isArrowFunction(decl.getInitializerOrThrow()) || Node.isFunctionExpression(decl.getInitializerOrThrow()))) {
        funcNode = decl.getInitializerOrThrow() as ArrowFunction;
      }


      if (funcNode) {
        const parameters = funcNode.getParameters().map(p => {
          const name = p.getName();
          const type = p.getTypeNode()?.getText() || 'any';
          const isOptional = p.hasQuestionToken();
          return `${name}${isOptional ? '?' : ''}: ${type}`;
        });
        // const returnType = funcNode.getReturnTypeNode()?.getText() || 'any';
        const numParams = parameters.length;
        const dummyParams = new Array(numParams).fill(0)
        exportedFunctions.push({
          name,
          // parameterStr: parameters.map(p => p.split(":")[0]).join(", "),
          // argumentStr: funcNode.getParameters().map(p => p.getName()).join(', ')
          parameterStr: dummyParams.map((p,i) => `p${i}`).join(", "),
          argumentStr: dummyParams.map((a, i) => `p${i}`).join(', ')
        })

        /*
        clientStubs += `
export async function ${name}(${parameters.map(p => p.split(":")[0]).join(", ")}) {
return makeRpcCall('${name}', [${funcNode.getParameters().map(p => p.getName()).join(', ')}]);
}
`;
*/
      }
    }

    // Clean up the temporary source file if you used createSourceFile
    project.removeSourceFile(sourceFile);
    // Or if using addSourceFileAtPath, you might manage it differently or let it be.
    // For multiple transforms, manage the ts-morph project instance carefully.

    return exportedFunctions;
  }
}

function makeClientStub(debug: boolean, filePath: string) {
  return `
// Generated by vite-plugin-sveltekit-telephone-dev
${debug ? "// Based on file: ${filePath}" : ""}
import { makeRpcCall } from 'vite-plugin-sveltekit-telephone-prod/client';

const filePath = ${JSON.stringify(filePath)}

async function makeSpecificRpcCall(functionName, args) {
    return await makeRpcCall(filePath, functionName, args)
}
`;
}